--- qt-4.8.5/src/gui/kernel/qwidget_mac.mm 2011-12-15 10:38:21.000000000 -0800
+++ qt-4.8.5/src/gui/kernel/qwidget_mac.mm   2012-09-18 17:17:03.000000000 -0700
@@ -1,22 +1,41 @@

@@ -4684,15 +4703,14 @@
     }

     // Scroll the whole widget if qscrollRect is not valid:
-    QRect validScrollRect = qscrollRect.isValid() ? qscrollRect : q->rect();
-    validScrollRect &= clipRect();
+    QRect validScrollRect = qscrollRect.isValid() ? qscrollRect : QRect(0, 0, q->width(), q->height());

     // If q is overlapped by other widgets, we cannot just blit pixels since
     // this will move overlapping widgets as well. In case we just update:
     const bool overlapped = isOverlapped(validScrollRect.translated(data.crect.topLeft()));
     const bool accelerateScroll = accelEnv && isOpaque && !overlapped;
     const bool isAlien = (q->internalWinId() == 0);
-    const QPoint scrollDelta(dx, dy);
+

     // If qscrollRect is valid, we are _not_ supposed to scroll q's children (as documented).
     // But we do scroll children (and the whole of q) if qscrollRect is invalid. This case is
@@ -4714,7 +4732,6 @@
         }else {
             update_sys(qscrollRect);
         }
-        return;
     }

 #ifdef QT_MAC_USE_COCOA
@@ -4731,6 +4748,7 @@
     // moved when the parent is scrolled. All directly or indirectly moved
     // children will receive a move event before the function call returns.
     QWidgetList movedChildren;
+    const QPoint scrollDelta(dx, dy);
     if (scrollChildren) {
         QObjectList children = q->children();