--- qt-4.8.5/src/gui/kernel/qwidget_mac.mm	2013-06-07 07:16:59.000000000 +0200
+++ qt-4.8.5-fix/src/gui/kernel/qwidget_mac.mm	2013-10-11 23:00:15.000000000 +0200
@@ -4715,15 +4715,13 @@ void QWidgetPrivate::scroll_sys(int dx, 
     }
 
     // Scroll the whole widget if qscrollRect is not valid:
-    QRect validScrollRect = qscrollRect.isValid() ? qscrollRect : q->rect();
-    validScrollRect &= clipRect();
+    QRect validScrollRect = qscrollRect.isValid() ? qscrollRect : QRect(0, 0, q->width(), q->height());
 
     // If q is overlapped by other widgets, we cannot just blit pixels since
     // this will move overlapping widgets as well. In case we just update:
     const bool overlapped = isOverlapped(validScrollRect.translated(data.crect.topLeft()));
     const bool accelerateScroll = accelEnv && isOpaque && !overlapped;
     const bool isAlien = (q->internalWinId() == 0);
-    const QPoint scrollDelta(dx, dy);
 
     // If qscrollRect is valid, we are _not_ supposed to scroll q's children (as documented).
     // But we do scroll children (and the whole of q) if qscrollRect is invalid. This case is
@@ -4745,7 +4743,6 @@ void QWidgetPrivate::scroll_sys(int dx, 
         }else {
             update_sys(qscrollRect);
         }
-        return;
     }
 
 #ifdef QT_MAC_USE_COCOA
@@ -4762,6 +4759,7 @@ void QWidgetPrivate::scroll_sys(int dx, 
     // moved when the parent is scrolled. All directly or indirectly moved
     // children will receive a move event before the function call returns.
     QWidgetList movedChildren;
+    const QPoint scrollDelta(dx, dy);
     if (scrollChildren) {
         QObjectList children = q->children();
 
